from typing import Tuple

import casadi.tools as castools
import numpy as np
from casadi import *
from do_mpc.data import Data, load_results
from do_mpc.model import Model


class POD_Model(Model):
    def __init__(self, snaps_path: str, model_type="continuous", symvar_type="SX"):
        """A Model that reduces the original state space of rank n to a much lower dimensional state space of rank r.
        This is done by utilizing proper orthogonal decomposition on a dataset that is generated by a rigorous model.

        To create the POD model, initialize it like your rigorous model and pass a path to a do_mpc.Data.pkl file
        with its corresponding data. The reduction is done automatically by the method "setup_pod()". Your original
        approximated states are stored and accessible with their original names as auxillary expressions
        for monitoring or constraints.

        To simulate, the initial state must be projected to the reduced space using the method "map()" before it
        is passed to the simulator or mpc-object.
        """
        super().__init__(model_type, symvar_type)
        self.r = None  # The rank of the reduced system
        self.U, self.S, _ = self.perform_svd(snaps_path=snaps_path)

    def derive_psi(self, r: int) -> np.array:
        self.r = r
        psi = self.U[:, : self.r]
        self.psi = psi
        return psi

    def perform_svd(self, snaps_path: str) -> Tuple[np.array]:
        """
        Perform Singular Value Decomposition on the data.
        """
        snaps = self.load_state_space_snaps(snaps_path=snaps_path)
        U, S, V_T = np.linalg.svd(snaps, full_matrices=False)
        return U, S, V_T

    def load_state_space_snaps(self, snaps_path: str) -> np.array:
        data = load_results(file_name=snaps_path)
        if "simulator" in data.keys():
            print(f"Loading state space snaps from {snaps_path}.")
            state_space_snapshots = data["simulator"]["_x"]
            return state_space_snapshots.T
        else:
            raise ValueError(f"No simulator data found in the data file {snaps_path}.")

    def map(self, x: np.array) -> np.array:
        """
        Maps the data to the reduced space.
        """
        assert (
            x.shape[0] == self.psi.shape[0]
        ), f"Full state vector x must be of lenght {self.psi.shape[0]} to match the data. It is of shape {x.shape}."
        return self.psi.T @ x

    def unmap(self, x_tilde: np.array) -> np.array:
        """
        Maps the data back to the original space.
        """
        return self.psi @ x_tilde

    def setup_pod(self):
        """Reduces the state space via Proper Orthogonal Decomposition from rank n to lower rank r."""
        x_tld = np.array(
            [
                self.set_variable(var_type="_x", var_name=f"x_tld_{i}")
                for i in range(self.r)
            ]
        ).reshape(
            -1, 1
        )  # the reduced states x_tilde
        x_approx = self.unmap(x_tilde=x_tld)  # the approximated full states

        old_vars = []
        rhs_expr = []
        for x_approx_i in x_approx:
            # delete the original state variables
            var_key = self._x["name"].pop(0)
            old_vars.append(self._x["var"].pop(0))
            # set them as auxillary expression
            self.set_expression(expr_name=var_key, expr=x_approx_i[0])
            # replace the original variables in the rhs with the approximated version
            rhs_expr.append(self.rhs_list[0]["expr"])
            self.rhs_list.pop(0)
        rhs_expr = castools.substitute(rhs_expr, old_vars, x_approx[:, 0].tolist())

        # map the full rhs back to the reduced space
        rhs_expr = np.array(rhs_expr).reshape(-1, 1)
        rhs_expr = self.map(x=rhs_expr)

        for i, expr_i in enumerate(rhs_expr):
            self.set_rhs(var_name=self._x["name"][i], expr=expr_i[0])

        super().setup()
